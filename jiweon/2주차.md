## HTTP

### Hypertext
> 참조(링크)를 통해 한문서에서 다른 문서로 "즉시" 접근 할 수 있는 텍스트이다.
> 

### 모든것이 HTTP
 - 초기에는 HTTP 는 단순히 HTML 만 주고 받는 프로토콜이였다.
 - 하지만 지금은 HTML 뿐 아니라, 이미지, 동영상, 파일 뿐만 아니라 
 - XML, JSON 같은 타입 등 거의 모든 형태에 데이터를 전송 할 수 있다.

### google.com 을 치게 되면 ... 
 1. 브라우저 URI 검색하는 창에 google.com 을 입력하게 되면 
 2. 브라우저는 먼저 local 에 찾고자 하는 DNS 에 대한 캐시 데이터 (해당 IP 주소) 가 있는지 찾고 
>있다면 해당 서버로 http request 를 보낸다. 

>없다면 DNS 서버에 해당 도메인에 대한 정보를 요청한뒤, 해당 정보를 local 에 캐쉬데이터로 저장한다. 
> 
>그 후 해당 서버로 http request 를 보낸다.
>
 3. 요청을 받은 서버 (구글)은 요청한 내용이 자신이 처리 할 수 있는 일인지, 확인 하고 

> 처리 할 수 있는 없는 요청이라면 4XX 번대 에러를 

> 처리 하다가 서버내부에서 에러가 난다면 5XX 번대 에러를 

> 정상적으로 처리가 되면 요청 데이터를 Http response 로 보내준다.

4. 응답 데이터를 받게되면 클라이언트는 응답에 대한 데이터를 어떻게 보여줄 것인지 가공을 하고,
5. 브라우저가 가공한 것을 토대로 모니터에 그려준다. 
6. 사용자는 모니터에 그려준 화면으로 확인한다. 

##HTTP 특징

### Keyword : 단순하고 확장성이 좋은 서비스.

### 클라이언트-서버구조 
>기존에 하나의 컴퓨터에서 처리하던 요청과 응답을 요청을 하는 클라이언트와 , 요청에 대한 응답을 해주는 서버로 역할과 책임을 나눈 아키텍쳐.

#### 이점  
1. 확장성이 뛰어나다. 
2. 클라이언트에서는 복잡한 비즈니스 로직이나 데이터 저장 같은 거에 대해서는 전혀 고려할 필요가 없다. 
UI,UX (사용자에게 어떻게 보여질 것인지) 에 대한 부분만 고려하면 되고,
<br>
반대로 서버 입장에서도 ,
UI,UX 부분은 고려하지 않아도 된다. (역할이 명확하니, 해당 역할에 대한 책임에만 집중 할 수 있다.)
3. 클라이언트 , 서버 양쪽이 **독립적**으로 진화 할 수 있다.

###무상태 프로토콜
>서버가 클라이언트의 상태에 대해 기억하지 않는다. 

#### 이점
1. 변경용이성, 확장성이 뛰어나다. (해당 서버 장애시 다른 서버로 대체 가능, 수평적 확장 (Scale-Out) 용이.)

#### 단점
1. 상태를 유지 하지 않기 때문에, 요청 데이터의 크기가 크다. 
<br>
ex) "어떤거에 어떤거를 이렇게 해주세요".

#### 실무 한계점
1. 모든 것을 무상태로 설계 할 수 없는 경우도 있다. 
> 로그인 같은 경우, 사용자가 로그인 했다는 상태를 서버에 유지 시켜 줘야 하기 때문에.
>

#### 해결법 
- 일반적으로 브라우저 쿠키 또는 서버 세션등을 통해 상태 유지.

#### 쿠키 , 세션, 토큰
- 등장 배경
> **사용자 정보를 저장 할때 !!! 계정정보를 헤더에 넣어 요청 할 경우 ...** 
> 
> **절대 이렇게 하면 안됩니다.** 보통 앱에서는 서버로 HTTP 요청을 할 때 따로 암호화 되지 않으므로, 해커가 HTTP 요청을 가로채서(intercept) 사용자의 계정정보를 알 수 있습니다.

##### 세션 & 쿠키 
 - Session/Cookie 방식 인증은 기본적으로 세션 저장소를 필요로 합니다. 
 - 세션 저장소는 로그인시 사용자 정보를 저장하고, 열쇠로 사용할 수 있는 세션 ID 를 만듭니다.
 - HTTP 헤더에 실어 클라이언트에게 보냅니다. 
 - 브라우저는 세션 ID 를 포함하는 쿠키를 저장하고있습니다.
 - 인증이 필요한 요청에 해당 쿠키를 끼워 서버에 request 를 보냅니다.

>사용자가 로그인을 합니다.
> 
>서버에서는 계정 정보를 읽어 사용자를 확인 후, 사용자의 고유 ID 값을 부여한 후 세션 저장소에 저장하고, 이와 연결되는 세션 ID 를 발행합니다.
> 
>클라이언트는 서버에서 해당 세션 ID 를 받아 쿠키에 저장 한 후, 인증이 필요한 요청마다 쿠키를 헤더에 끼워 보냅니다.
> 
>서버에서는 쿠키를 받아 세션 저장소에서 확인 한 후, 일치하는 정보를 가져옵니다.
> 
>인증이 완료되고 서버는 사용자에 맞는 데이터를 보내줍니다.

##### 세션과 쿠키 차이점
>Session : 서버에서 가지고있는 정보
>
>Cookie : 서버에서 발급된 세션을 열기 위한 키 값(세션 ID 라고 칭함)
> 
> 쿠키만으로 인증을 한다는 것은서버의 자원은 사용하지 않는다는 것 - 클라이언트가 인증 정보를 책임지는 것을 의미합니다.
> 
> 보안에 취약...
> 
> **세션 보안에 대해서 생각해보자.**
> >비밀번호와 같은 인증 정보를 쿠키에 저장하지 않고 대신에 사용자의 식별자인 JSESSIONID(session id)를 저장한다. 서버에는 인증 정보와 더불어 이 ID에 해당하는 로그인 상태, 마지막 로그인 시간, 닉네임, 만료기한 등의 정보를 저장한다. 보안상 서버는 사용자의 개인 컴퓨터보다는 훨씬 안전하기 때문에 인증에 Session을 이용한다


#### 무상태 프로토콜과 토큰의 출현.
- 세션도 하나의 서버이기 때문에, 큰 서비스의 경우 하나의 세션저장소에 정보를 저장하기 힘든 경우가 있다.
- 이럴 경우 상태프로토콜과 같은 문제가 발생 할 수 있다.

- 그래서 나온 것이 토큰 인증 방식.
- 사용자 정보를 포함한 데이터를 암호화 하여 토큰으로 만들고 (암호화 방식은 서버만 알고 있다.)
- 해당 값을 헤더로 전달. 
- 세션 처럼 저장공간 따로 필요하지 않음.

#### 결론 : 최대한 무상태 로 설계를 하자. 정말 어쩔수 없는 경우에만 상태를 유지하자.

###비연결성
> 어떤 클라이언트의 http request 에 대해 response 를 보냈다면 해당 클라이언트와 연결을 끊는다. (서버마다, 일정시간 더 보낼건 없는지 wait 할 수도 있음)

####이점
- 수많은 클라이언트에 대해 연결을 유지하지 않아도 된다.
- 서버 자원을 효율적으로 사용가능
> 요청을 하지 않는 클라이언트와 연결을 맺고 있지 않아도 된다. (불필요한 서버 자원 소모하지 않는다.)

####단점
- 매 요청마다 새로운 connection 을 맺어야한다. 
> 한페이지를 구성하기 위해 html , 이미지, css , js 등 여러가지 데이터가 필요할 수 있는데 
> 
>이를 가져올때마다 하나씩 connection 을 맺고 끊는것은 비효율 적이다.
> 
> 오버헤드로 이어짐

####극복
> 응답을 보내고 연결을 바로 끊는것이 아닌, 일정시간동안 연결을 유지 하면서, 불필요한 connection 비용을 최소화한다.
> 

####HTTP 2.0 최적화
>

### [번외] 서버개발자들이 어려워하는 실무 상황

> 선착순 이벤트, 수강신청 , 콘서트 티켓 예매 등과 같은 같은 시간에 딱 맞추어 발생하는 대용량 트래픽

#### 해소법
1. 최대한 Stateless 하게 설계하자.
> Stateless 하다면, 대용량 트래픽이 발생하는 시간동안 Scale-Out 으로 서버를 수평적 확장하고 
> 
> load-balancing 을 통해 대용량 트래픽을 해소 할 수 있다.

2. 해당 이벤트를 요청하기전에 정적 페이지를 하나 중간에 두어서 트래픽을 분산시킨다.

####생각해보기
> **위의 해소법 외에 대용량 트래픽을 해소 할 수 있는 방법 생각해보자.**

###HTTP 메시지

#### 구조
> 시작라인 
> ___
> 헤더
> ___
> 공백라인
> ___
> 바디

### HTTP API

####URI 설계 
- **URI 는 리소스를 기준으로 설계하자.**
- 처리하려는 행위는 HTTP METHOD 를 통해 표현하자.

####생각해보기
> URI 를 왜 리소스 기준으로 설계해야할까? 그냥 편하게 쓰면 안되나?
> 
> **<나의 생각>** 
> 
> 우리가 대부분 많이 사용하는 URI 중 URL 의 뜻을 보면 <br>
> "Uniform Resource Locator" 즉 인터넷 상에 존재하는 자원의 위치를 나타내는 식별자이다.
> 
> 예를 들어, 우리가 User 라는 자원에 대해 조회를 할 수 도 있고 , 저장을 하는 등의 여러 행위를 한다고 가정 해보자.
> 
> 우리가 어떤 행위를 하든 우리가 접근 하는 자원은 User 이다. 
>
> "https:www.naver.com/updateUser" 
> 
> "https:www.naver.com/createUser" 
> 
> 위의 URL 을 해석해보면 naver.com 의 updateUser 위치에 있는 자원과,
> 
> naver.com 의 createUser 위치에 있는 자원을 접근 하겠다는 건데 우리가 처음 의도한 것과 조금은 다르다는것을 느낄 수 있다.
> 
> update 를 하든 create 를 하든 우리는 user 에 대한 자원에 접근 하겠다는 거라서 리소스를 기준으로 설계 하라 라는 말을 하셨다 라고 생각한다.
> 
> **다른 스터디원들 생각 들어보기 ...**
> 

###HTTP METHOD
 - GET 
> 전달 하고 싶은 데이터를 query (쿼리 파라미터) 를 통해서 전달.
> 
> 바디로 데이터 전달 가능은 하다. 지원하지 않는 서버도 있기 때문에, 권장하지 않는다.

- POST
> 바디를 통해 서버로 요청 데이터 전달 -> 서버에게 요청 데이터를 **처리** 해달라고 요청.
>
> 주로 신규 데이터 등록
> 
> 처리 방식은 다양함. 

-PUT
> 리소스를 완전히 대체 (덮어쓰기), 없으면 생성.
> 
> Post 와 Put 의 차이점 ? 
> 
> >내 생각에는 Post 와 Put 의 차이점 이라기 보단, 생성과 수정의 차이점 이라고 생각한다.
> >
> >스터디원의 의견은??
> 
> 클라이언트가 리소스 위치를 알고 URI 지정.

####스터디원의 의견 POST , PUT 멱등성의 차이.

-PATCH
> 부분변경 하고 싶으면 PATCH 를 써라.
> 
> PATCH 안될 경우 Post 메서드 사용.

-DELETE
> 삭제 하고 싶으면 DELETE 를 써라.

###정리 할 내용
> 멱등성 ,POST, PUT
> 
> Session 방식 과 토큰 방식 
> 
> 토큰 방식의 메커니즘
> 
> Refresh 토큰은 왜 사용할까?